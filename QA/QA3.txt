Вопросы.
a. Какой класс отвечает за работу с MySQL? Как осуществляется
работа?
b. В каком формате объект указанного Вами класса возвращает
результат SQL запроса Select?
c. Опишите структуру и основные принципы работы с
коллекцией ХЕШ.
d. Опишите структуру и основные принципы работы с
коллекцией множество.
e. Опишите проблему и место паттерна одиночка в разработке.
f. Напишите на бумаге пример реализации данного паттерна и
способ проверки корректности его работы.
g. Попытайтесь снова сформулировать ответ на вопрос – В чем
необходимость использования полей и методов класса?
h. Что такое метод класса, в чем его отличие от метода объекта?
Приведите два практических примера, когда введение метода класса вы
считаете необходимым согласно концепциям ООП.

------------------------------------------------------------------------------------

a. В Ruby для работы с MySQL используется класс Mysql2, который является реализацией клиента для MySQL баз данных.
Затем можно создать соединение с базой данных, используя класс Mysql2::Client и передав в конструктор параметры подключения:

client = Mysql2::Client.new(
  host: 'localhost',
  username: 'root',
  password: 'password',
  database: 'mydatabase'
)

b. Объект указанного класса Mysql2::Result возвращает результат SQL-запроса SELECT в виде массива хэшей, 
где каждый хэш соответствует строке результирующего набора, а ключи хэша — имена столбцов, а значения — данные в соответствующих столбцах.
Каждый хэш можно получить методом Mysql2::Result#each, который вызывается на объекте результата запроса

c. В Ruby коллекция хэшей - это структура данных, в которой хранятся
пары ключ-значение. Основными принципами работы с хэшем являются:

Создайте новый хэш, используя синтаксис {} или Hash.new
Храните значения, используя синтаксис hash[key] = value
Извлекайте значения, используя синтаксис hash[key]
Перебирайте ключи и значения, используя метод each
Проверить наличие ключа с помощью has_key? или включить? методы
Удалите ключи и значения, используя метод удаления

d. Коллекция Set - это структура данных, в которой хранятся уникальные элементы
без какого-либо определенного порядка. Основными принципами работы с набором являются:

Создайте новый набор, используя метод Set.new
Добавьте элементы в набор, используя методы add или <<
Удалите элементы из набора с помощью метода delete
Проверить наличие элемента с помощью include? метод
Перебирайте элементы, используя метод each
Выполните операции набора, такие как объединение, пересечение и разность, используя соответствующие методы

e. Шаблон Singleton - это шаблон проектирования, который гарантирует,
что класс имеет только один экземпляр, и он предоставляет глобальную точку доступа
к этому экземпляру. Это полезно, когда вам нужно контролировать доступ к общим ресурсам,
таким как данные конфигурации или пул подключений.

g. Поля и методы класса используются в Ruby для хранения данных и выполнения действий,
которые относятся к классу в целом, а не к конкретному экземпляру класса.
Они могут быть полезны для управления общими ресурсами или предоставления служебных методов,
которые не зависят от состояния отдельного объекта.

h. Метод класса - это метод, который принадлежит самому классу, а не экземпляру класса.
Основное различие между методом класса и методом объекта заключается в том, что
методы класса вызываются в классе, в то время как методы объекта вызываются в экземпляре класса.
Вот два практических примера, когда введение метода класса необходимо в соответствии с концепциями ООП:

Примеры методов класса:

Метод, возвращающий новый экземпляр класса с предустановленными значениями. Например, 
класс Person может иметь метод класса create_default, который возвращает новый объект Person с заполненными полями по умолчанию.

Метод, создающий новый объект класса на основе данных внешнего источника, например, из базы данных или файла. В этом случае метод класса обычно принимает параметры, 
необходимые для получения данных и создания нового объекта. Например, класс User может иметь метод класса find_by_email, 
который находит пользователя в базе данных по его email и возвращает новый объект User с данными из базы.


Вопросы.
a. * (НЕ ОБЯЗАТЕЛЬНО) Опишите проблематику, в которой
необходим паттерн адаптер.
b. * (НЕ ОБЯЗАТЕЛЬНО) Приведите на листе бумаге тривиальный
пример реализации этого паттерна.
c. * (НЕ ОБЯЗАТЕЛЬНО) Опишите словами место в проекте, где
возможно применение данного паттерна, Опишите Вашу реализацию
паттерна адаптер.
d. * (НЕ ОБЯЗАТЕЛЬНО) Опишите, как вы понимаете утверждение –
проектируйте на уровне интерфейсов, а не реализаций

------------------------------------------------------------------------------------------------
a. Паттерн адаптер используется для решения проблемы несовместимости интерфейсов. Когда у двух классов различные интерфейсы и 
необходимо использовать один из них в контексте другого, то для этого используется адаптер, который предоставляет единый интерфейс для взаимодействия этих классов.

Примеры ситуаций, в которых может потребоваться паттерн адаптер:

Использование сторонней библиотеки, которая имеет свой уникальный интерфейс,
но ее функциональность нужна в контексте существующего приложения, которое уже использует другой интерфейс.

Изменение интерфейса класса, который уже используется в приложении, без изменения остального кода. 
В этом случае можно создать адаптер для старого интерфейса и использовать его, пока не будет полностью переход на новый интерфейс.

Необходимость использования класса в разных контекстах, но для каждого контекста требуется свой интерфейс. 
Создание адаптера позволяет использовать один и тот же класс в разных контекстах, не изменяя его интерфейс.

d. Утверждение "проектируйте на уровне интерфейсов, а не реализаций" означает, что при проектировании системы или компонента необходимо сначала определить, 
каким должен быть интерфейс, т.е. какими функциями и методами он должен обладать, а затем уже разрабатывать его реализацию.

Это подход, который согласуется с принципом инкапсуляции, одним из ключевых принципов объектно-ориентированного программирования. 
Инкапсуляция заключается в том, что данные и методы работы с ними должны быть скрыты от внешнего мира и доступны только через определенный интерфейс. 
Это позволяет достичь большей гибкости и удобства при разработке и тестировании системы, а также упрощает ее сопровождение и модификацию в будущем.

Кроме того, проектирование на уровне интерфейсов позволяет уменьшить зависимость компонентов друг от друга, поскольку они могут использовать только определенный набор функций, 
а не прямой доступ к реализации. Это делает систему более модульной и позволяет легче добавлять, изменять или заменять компоненты в будущем.